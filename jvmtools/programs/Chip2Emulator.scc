
program {


    fun main() {

        uint16 SCREEN_BUF_BOT = $F00;
        uint16 SCREEN_BUF_TOP = $FFF;

        uint16 FONT_ADDR = $50;
        uint16 PC_INIT = $200;

        uint16 GOTO_INIT_STATE = 0;
        uint16 GOTO_SETX_STATE = 1;  // switch state
        uint16 GOTO_SETY_STATE = 2;  // switch state
        uint16 GOTO_DRAW_PIXEL_STATE = 3; // switch state
        uint16 GOTO_DRAW_BYTE_STATE = 4; // switch state
        uint16 GOTO_LOG_CHAR_STATE = 5; // switch state
        uint16 GOTO_LOG_BYTE_STATE = 6; // switch state
        uint16 DO_CLEAR = 10;
        uint16 DO_UP = 11;
        uint16 DO_DOWN = 12;
        uint16 DO_LEFT = 13;
        uint16 DO_RIGHT = 14;
        uint16 DO_ORIGIN = 15;
        uint16 DO_CENTRE = 16;
        uint16 GOTO_LOG_OPCODE = 17;
        uint16 GOTO_LOG_STRING = 18;

        uint16 SCREEN_HEIGHT = 32;
        uint16 SCREEN_WIDTH = 64;

        // 32*64=screen size
        var screen = [2*32*64: [0]];


        // 16 x 8 bits
        var registers = [16: [0]];

        // 16 x 16 bits
        var stack = [32: [0]];

        uint16 FontMemAddress = $50;
        uint16 FontCharWidth = 5;

        var memory = [
                // fonts : 10 rows = 10 digits, each row of 5 bytes defines the 5 rows of 8 pixels wide
                $50  : [
                        $F0 $90 $90 $90 $F0
                        $20 $60 $20 $20 $70
                        $F0 $10 $F0 $80 $F0
                        $F0 $10 $F0 $10 $F0
                        $90 $90 $F0 $10 $10
                        $F0 $80 $F0 $10 $F0
                        $F0 $80 $F0 $90 $F0
                        $F0 $10 $20 $40 $40
                        $F0 $90 $F0 $90 $F0
                        $F0 $90 $F0 $10 $F0
                        $F0 $90 $F0 $90 $90
                        $E0 $90 $E0 $90 $E0
                        $F0 $80 $80 $80 $F0
                        $E0 $90 $90 $90 $E0
                        $F0 $80 $F0 $80 $F0
                        $F0 $80 $F0 $80 $80
                ]

                // program
                // $200 : [file("/home/john/OneDrive/github/johnlon/chip-8/src/main/resources/chip8/roms/IBM_Logo.ch8")]
                //$200 : [hexfile(systemProp("CHIP8_FILENAME"))]
                $200 : [file(systemProp("CHIP8_FILENAME"))]

                // memory limit - put a zero explicitly at posn - this has same effect as as "$FFF=[]"
                $0FFF: [0] // 4k
        ];

        uint16 pc = PC_INIT;
        uint16 index = 0;
        uint16 stackPtr = 0;

        // reset by sending this twice
        putuart(GOTO_INIT_STATE)
        putuart(GOTO_INIT_STATE)

        putuart(GOTO_LOG_STRING)
        putuart(3)
        putuart('G')
        putuart('O')
        putuart('\n')

        uint16 keyDown = $100;

        while (true) {
            uint16 opcodehi = memory[pc];
            uint16 opcodelo = memory[pc + 1];
            uint16 opcode = (opcodehi << 8) + opcodelo;
            uint16 keyLast = getuart(); // no key = x100 otherwise 0-255

            if (keyLast != $100) {
                keyDown = keyLast;
            }

        putfuart(X, pc>>8)
        putfuart(X, pc)
        putfuart(C, ':')
        putfuart(C, 32)
        putfuart(X, opcodehi)
        putfuart(X, opcodelo)
        putfuart(C, 32)

        putfuart(C, 'K')
        putfuart(C, ':')
        putfuart(X, keyDown >> 8)
        putfuart(X, keyDown)
        putfuart(C, 32)
            
        putfuart(C, 'I')
        putfuart(C, ':')
        putfuart(X, index>>8)
        putfuart(X, index)
        putfuart(C, 32)

        putfuart(C, '0')
        putfuart(C, ':')
        putfuart(X, registers[0])
        putfuart(C, 32)
        putfuart(C, '1')
        putfuart(C, ':')
        putfuart(X, registers[1])
        putfuart(C, 32)
        putfuart(C, '2')
        putfuart(C, ':')
        putfuart(X, registers[2])
        putfuart(C, 32)
        putfuart(C, '3')
        putfuart(C, ':')
        putfuart(X, registers[3])
        putfuart(C, 32)
        putfuart(C, '4')
        putfuart(C, ':')
        putfuart(X, registers[4])
        putfuart(C, 32)
        putfuart(C, '5')
        putfuart(C, ':')
        putfuart(X, registers[5])
        putfuart(C, 32)
        putfuart(C, '6')
        putfuart(C, ':')
        putfuart(X, registers[6])
        putfuart(C, 32)
        putfuart(C, '7')
        putfuart(C, ':')
        putfuart(X, registers[7])
        putfuart(C, 32)
        putfuart(C, '8')
        putfuart(C, ':')
        putfuart(X, registers[8])
        putfuart(C, 32)
        putfuart(C, '9')
        putfuart(C, ':')
        putfuart(X, registers[9])
        putfuart(C, 32)
        putfuart(C, 'A')
        putfuart(C, ':')
        putfuart(X, registers[10])
        putfuart(C, 32)
        putfuart(C, 'B')
        putfuart(C, ':')
        putfuart(X, registers[11])
        putfuart(C, 32)
        putfuart(C, 'C')
        putfuart(C, ':')
        putfuart(X, registers[12])
        putfuart(C, 32)
        putfuart(C, 'D')
        putfuart(C, ':')
        putfuart(X, registers[13])
        putfuart(C, 32)
        putfuart(C, 'E')
        putfuart(C, ':')
        putfuart(X, registers[14])
        putfuart(C, 32)
        putfuart(C, 'F')
        putfuart(C, ':')
        putfuart(X, registers[15])
        putfuart(C, 32)


            uint16 N___ = opcode & $f000;
            uint16 _NNN = opcode & $0fff;
            uint16 _X__ = opcodehi & $0f;
            uint16 __Y_ = opcodelo >> 4;
            uint16 __NN = opcodelo;
            uint16 ___N = opcodelo & $0f;

            uint16 x = registers[_X__];
            uint16 y = registers[__Y_];

            if (opcode == $00e0) {
                // draw
                putuart(DO_CLEAR)

        putfuart(C, 'C')
        putfuart(C, 'L')
        putfuart(C, 'S')

            } else if (opcode == $00ee) { // DONE
                // ReturnSub
                // return by pulling address off stack
                stackPtr = stackPtr - 1;
                uint16 addrLo = stack[stackPtr];
                stackPtr = stackPtr - 1;
                uint16 addrHi = stack[stackPtr];
                pc = (addrHi << 8) + addrLo;

        putfuart(C, 'R')
        putfuart(C, 'T')
        putfuart(C, 'S')

            } else if (opcodehi == $00) {
                // obsolete machine jump
        putfuart(C, 'O')
        putfuart(C, 'B')
        putfuart(C, 'S')

            } else if (N___ == $1000) {  // DONE
                // jump to nnn
                pc = _NNN - 2; // subtract 2 as there is an auto increment at end of loop
        putfuart(C, 'J')
        putfuart(C, 'M')
        putfuart(C, 'P')
        putfuart(C, 32)
        putfuart(X, _NNN>>8)
        putfuart(X, _NNN)

            } else if (N___ == $2000) {  // DONE
        putfuart(C, 'C')
        putfuart(C, 'A')
        putfuart(C, 'L')
        putfuart(C, 'L')
        putfuart(C, 32)
        putfuart(X, _NNN>>8)
        putfuart(X, _NNN)
                // CALL _NNN
                // tested using test_opcode.ch8

                // store into stack
                uint16 addrLo = pc & $ff;
                uint16 addrHi = pc >> 8;

                stack[stackPtr] = addrHi;
                stackPtr = stackPtr + 1;
                stack[stackPtr] = addrLo;
                stackPtr = stackPtr + 1;

                // do jump
                pc = _NNN - 2;

            } else if (N___ == $3000) {  // DONE
                // skip if X eq N
        putfuart(C, 'S')
        putfuart(C, 'K')
        putfuart(C, 'I')
        putfuart(C, 'P')
        putfuart(C, 32)
        putfuart(C, 'X')
        putfuart(C, '=')
        putfuart(C, 'N')
        putfuart(C, 32)
        putfuart(X, x)
        putfuart(C, '=')
        putfuart(X, __NN)
        putfuart(C, 32)

                if (x == __NN) {
                    pc = pc + 2;
        putfuart(C, 'Y')
                } else {
        putfuart(C, 'N')
                }

            } else if (N___ == $4000) {  // DONE
                // skip if X ne N
        putfuart(C, 'S')
        putfuart(C, 'K')
        putfuart(C, 'I')
        putfuart(C, 'P')
        putfuart(C, 32)
        putfuart(C, 'X')
        putfuart(C, '!')
        putfuart(C, '=')
        putfuart(C, 'N')
        putfuart(C, 32)
        putfuart(X, x)
        putfuart(C, '=')
        putfuart(X, __NN)
        putfuart(C, 32)


                if (x != __NN) {
                    pc = pc + 2;
        putfuart(C, 'Y')
                } else {
        putfuart(C, 'N')
                }
    

            } else if (N___ == $5000) {  // DONE
                // skip if X eq Y
        putfuart(C, 'S')
        putfuart(C, 'K')
        putfuart(C, 'I')
        putfuart(C, 'P')
        putfuart(C, 32)
        putfuart(C, 'X')
        putfuart(C, '=')
        putfuart(C, 'Y')
        putfuart(C, 32)
        putfuart(X, x)
        putfuart(C, '=')
        putfuart(X, y)
        putfuart(C, 32)

                if (___N != 0) {
                    halt(opcode)
                }
                if (x == y) {
                    pc = pc + 2;
        putfuart(C, 'Y')
                } else {
        putfuart(C, 'N')
                }

            } else if (N___ == $6000) { // DONE
                // VX=__NN
                registers[_X__] = __NN;
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'N')
        putfuart(C, 32)
        putfuart(X, __NN)

            } else if (N___ == $7000) { // DONE
                // VX=VX+__NN
                registers[_X__] = x + __NN;
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'X')
        putfuart(C, '+')
        putfuart(C, 'N')
        putfuart(C, 32)
        putfuart(X, x)
        putfuart(C, '+')
        putfuart(X, __NN)

            } else if (N___ == $8000) {
                if (___N == 0) {
                    registers[_X__] = y;
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'Y')
        putfuart(C, 32)
        putfuart(X, y)

                } else if (___N == 1) {
                    registers[_X__] = x | y;

        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'X')
        putfuart(C, '|')
        putfuart(C, 'Y')
        putfuart(C, 32)
        putfuart(X, x)
        putfuart(C, '|')
        putfuart(X, y)

                } else if (___N == 2) {
                    registers[_X__] = x & y;
                } else if (___N == 3) {
                    registers[_X__] = x ^ y;
                } else if (___N == 4) {
                    //AddXPlusYCarry

                    uint16 result = x + y;
                    registers[_X__] = result;

        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'X')
        putfuart(C, '+')
        putfuart(C, 'Y')
        putfuart(C, 32)
        putfuart(X, x)
        putfuart(C, '+')
        putfuart(X, y)
        putfuart(C, '=')
        putfuart(X, result)
        putfuart(C, 32)
        putfuart(C, 'C')

                    if (result > $ff) {
                        registers[15] = 1;
                    } else {
                        registers[15] = 0;
                    }
        putfuart(X, registers[15])

                } else if (___N == 5) {
                    // XEqXMinusY
                    if (x < y) {
                        // active low
                        registers[15] = 0;
                    } else {
                        registers[15] = 1;
                    }
                    registers[_X__] = x - y;
                } else if (___N == 6) {
                    // X = X >> 1
                    if ((x & 1) != 0) {
                        registers[15] = 1;
                    } else {
                        registers[15] = 0;
                    }
                    registers[_X__] = x >> 1;
                } else if (___N == 7) {
                    // X = Y - X with carry
                    if (x > y) {
                        // active low
                        registers[15] = 0;
                    } else {
                        registers[15] = 1;
                    }
                    registers[_X__] = y - x;

                } else if (___N == $e) {
                    // X = X << 1
                    if ((x & % 10000000) != 0) {
                        registers[15] = 1;
                    } else {
                        registers[15] = 0;
                    }
                    registers[_X__] = x << 1;
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'X')
        putfuart(C, '<')
        putfuart(C, '<')
        putfuart(C, '1')
        putfuart(C, 32)
        putfuart(C, '=')
        putfuart(X, registers[_X__])

                } else {
                    // not impl F0xx
                    halt(opcode)
                }
            } else if (N___ == $9000) {
                // ADDED VIA test_opcode.ch8
                if (___N == 0) {
                    // skipIfXNeY(opS, _X__, __Y_)
                    if (x != y) {
                        pc = pc + 2;
                    }
                } else {
                    // not impl F0xx
                    halt(opcode)
                }
            } else if (N___ == $A000) { // DONE
                // set index
                //putuart('I')
                index = _NNN;
        putfuart(C, 'I')
        putfuart(C, '=')
        putfuart(C, 'N')
        putfuart(C, 32)
        putfuart(C, '=')
        putfuart(X, index>>8)
        putfuart(X, index)

            } else if (N___ == $C000) { // DONE
                // http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#Cxkk
                // Vx = Random AND __NN
                // TODO : IMPLEMENT RANDOM
                uint16 rand = random();
                registers[_X__] = rand & __NN;
                
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'R')
        putfuart(C, 'N')
        putfuart(C, 'D')
        putfuart(C, '&')
        putfuart(C, 'N')
        putfuart(C, 32)
        putfuart(X, rand)
        putfuart(C, '&')
        putfuart(X, __NN)
        putfuart(C, '=')
        putfuart(X, registers[_X__])

            } else if (N___ == $D000) {
                // draw glyph identified by Index reg at position X/Y with height N
// as per https://tobiasvl.github.io/blog/write-a-chip-8-emulator/#dxyn-display
// TODO - NEED TO MAINTAIN A SCREEN BUFF     60x40=2.5k

                uint16 xpos = x;
                uint16 ypos = y;

                uint16 ycount = 0;

        putfuart(C, 'D')
        putfuart(C, 'R')
        putfuart(C, 'A')
        putfuart(C, 'W')
        putfuart(C, 32)
        putfuart(C, 'X')
        putfuart(X, x)
        putfuart(C, 32)
        putfuart(C, 'Y')
        putfuart(X, y)
        putfuart(C, 32)
        putfuart(C, 'N')
        putfuart(X, ___N)

                while (true) { // TODO - make while take an expr

                    // TODO THIS DOESN@T WORK ... POSSIBLY 3 vars doesn't work?
                    // uint16 rowStart = (ycount+ypos)*SCREEN_WIDTH;

                    uint16 rowStart = (ycount+ypos)*64; // SCREEN_WIDTH;
                    uint16 pixelPos = rowStart+ xpos; 
                    uint16 rowLimit = rowStart+ SCREEN_WIDTH;

                    if (ycount >= ___N) {
                        break
                    }

                    uint16 glyphRow = memory[index + ycount];

                    // g0 is leftmost on screen
                    uint16 s7 = screen[pixelPos]  ;
                    uint16 s6 = screen[pixelPos+1];
                    uint16 s5 = screen[pixelPos+2];
                    uint16 s4 = screen[pixelPos+3];
                    uint16 s3 = screen[pixelPos+4];
                    uint16 s2 = screen[pixelPos+5];
                    uint16 s1 = screen[pixelPos+6];
                    uint16 s0 = screen[pixelPos+7];

                    uint16 screenRow = (s7<<7) | (s6<<6) | (s5<<5) | (s4<<4) | (s3<<3) | (s2<<2) | (s1<<1) | s0; 

                    uint16 newScreen = screenRow ^ glyphRow;
                    uint16 impact = screenRow & glyphRow;

                    putuart(GOTO_SETX_STATE)
                    putuart(xpos)
                    putuart(GOTO_SETY_STATE)
                    putuart(ypos + ycount)
                    putuart(GOTO_DRAW_BYTE_STATE)
                    putuart(newScreen)


                    if (pixelPos < rowLimit) {
                        screen[pixelPos+0] = (newScreen&128)>>7;
                        if ((pixelPos+1) < rowLimit) {
                            screen[pixelPos+1] = (newScreen&64)>>6;
                            if ((pixelPos+2) < rowLimit) {
                                screen[pixelPos+2] = (newScreen&32)>>5;
                                if ((pixelPos+3) < rowLimit) {
                                    screen[pixelPos+3] = (newScreen&16)>>4;
                                    if ((pixelPos+4) < rowLimit) {
                                        screen[pixelPos+4] = (newScreen&8)>>3;
                                        if ((pixelPos+5) < rowLimit) {
                                            screen[pixelPos+5] = (newScreen&4)>>2;
                                            if ((pixelPos+6) < rowLimit) {
                                                screen[pixelPos+6] = (newScreen&2)>>1;
                                                if ((pixelPos+7) < rowLimit) {
                                                    screen[pixelPos+7] = (newScreen&1);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (impact!=0) {
                        registers[15] = 1;
                    }

                    ycount = ycount + 1;
                }

            } else if (N___ == $E000) {
                if (__NN == $A1) {
    /*
    ExA1 - SKNP Vx
    Skip next instruction if key with the value of Vx is not pressed.
    Checks the keyboard, and if the key corresponding to the value of Vx is currently in the up position, PC is increased by 2.
    */
                    // TODO IMPL KEYPRESS IO FROM UART??? GETCHAR?
                    uint16 key = x;


        putfuart(C, 'S')
        putfuart(C, 'K')
        putfuart(C, 'I')
        putfuart(C, 'P')
        putfuart(C, 32)
        putfuart(C, '!')
        putfuart(C, 'K')
        putfuart(C, 'E')
        putfuart(C, 'Y')
        putfuart(C, 32)
        putfuart(X, key)
        putfuart(C, 32)

                    if (keyDown != key) {
                         pc = pc + 2;
        putfuart(C, 'Y')
                    } else {
        putfuart(C, 'N')
                    }
                } else if (__NN == $9E) {
                    // skip; if key x is pressed
                    uint16 key = x;


        putfuart(C, 'S')
        putfuart(C, 'K')
        putfuart(C, 'I')
        putfuart(C, 'P')
        putfuart(C, 32)
        putfuart(C, 'K')
        putfuart(C, 'E')
        putfuart(C, 'Y')
        putfuart(C, 32)
        putfuart(X, key)

                    if (keyDown == key) {
                         pc = pc + 2;
        putfuart(C, 'Y')
                    } else {
        putfuart(C, 'N')
                    }

                } else {
                    // not impl F0xx
                    halt(opcode)
                }


            } else if (N___ == $F000) {
                if (__NN == $07) {
                    // GET DELAY TIMER
                    // TODO WORK OUT HOW MANY CYCLES FOR 60 Hz
                    // http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#Fx07
                    registers[_X__] = 0;

                    // FIXME - hack so it's sometimes non zero
                    uint16 rand = random();
                    if (rand > 128) {
                        registers[_X__] = random();
                    }

        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(C, 'D')
        putfuart(C, 'T')
        putfuart(C, '=')
        putfuart(X, registers[_X__])

                } else if (__NN == $15) {
                    // SET DELAY TIMER
                    // TODO WORK OUT HOW MANY CYCLES FOR 60 Hz
                    // http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#Fx15
                    uint16 DT = registers[_X__];
        putfuart(C, 'D')
        putfuart(C, 'T')
        putfuart(C, '=')
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, '=')
        putfuart(X, x)

                } else if (__NN == $18) {
                    // SET SOUND TIMER
                    // TODO WORK OUT HOW MANY CYCLES FOR 60 Hz
                    // http://devernay.free.fr/hacks/chip8/C8TECH10.HTM#Fx18
                    uint16 ST = registers[_X__];

                } else if (__NN == $1E) {
                    // INDEX += REG[X]
                    // set carry if index exceeds mem size of 4096
                    uint16 oldI = index;
                    index = index + x;                  
                    if (index > 4095) {
                        registers[15] = 1;
                    } else {
                        registers[15] = 0;
                    }
        putfuart(C, 'I')
        putfuart(C, '=')
        putfuart(C, 'I')
        putfuart(C, '+')
        putfuart(C, 'V')
        putfuart(X, _X__)
        putfuart(C, 32)
        putfuart(X, oldI>>8)
        putfuart(X, oldI)
        putfuart(C, '+')
        putfuart(X, x)
        putfuart(C, '=')
        putfuart(X, index>>8)
        putfuart(X, index)
        putfuart(C, 32)
        putfuart(C, 'C')
        putfuart(X, registers[15])

                } else if (__NN == $29) {
                    uint16 ch = registers[_X__];
                    uint16 offset = ch * FontCharWidth;

                    uint16 locn = FontMemAddress + offset;
                    index = locn;

                } else if (__NN == $33) {
                    // BCD conversion
                    uint16 i100 = x / 100;
                    uint16 xDiv10 = x / 10;
                    uint16 i10 = xDiv10 - (10 * i100);
                    uint16 i1 = x - (10 * xDiv10);

                    memory[index] = i100;
                    memory[index+1] = i10;
                    memory[index+2] = i1;

                } else if (__NN == $55) {
                    uint16 i = 0;
                    while (true) {
                        memory[index + i] = registers[i];

                        i = i + 1;
                        if (i > _X__) {
                            break
                        }
                    }
                    // NB THERE IS AN OPTIONAL LEGACY STEP HERE THAT SOME PROGS MIGHT RELY ON
                    //       index = if (LoadStoreBehaviour == Legacy) (st.index + xReg.ubyte + 1) else st.index
                } else if (__NN == $65) {
                    uint16 i = 0;

                    while (true) {
                        registers[i] = memory[index + i];

                        i = i + 1;
                        if (i > _X__) {
                            break
                        }
                    }
                    // NB THERE IS AN OPTIONAL LEGACY STEP HERE THAT SOME PROGS MIGHT RELY ON
                    //       index = if (LoadStoreBehaviour == Legacy) (st.index + xReg.ubyte + 1) else st.index


                } else {
                    // not impl F0xx
                    halt(opcode)
                }
            } else {
                // not impl top level
                halt(opcode)
            }

            putfuart(C, '\n')

            pc = pc + 2;
        }

    }
}
